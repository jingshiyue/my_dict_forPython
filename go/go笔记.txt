go build 
go install 
go run main.go
go mod init xxx
go跨平台编译:


下载个>1.14版本go
    设置代理，GOPROXY=https://goproxy.io,direct，可以打开任意文件夹，在vscode里打开
    go mod init xxx

每行可以不加分号
" { "不能单独一行
:= 只能函数内使用
fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b ); 变量类型

动态数组  
    myarry [4]int   声明
    myarry := [4]int{1，2，3，4} 
    在函数调用时是引用传递
静态数组  
    myarry []int   声明
    myarry := []int{1，2，3，4}
    在函数调用时是值传递，传参是值拷贝
    
指针用于存放地址，指针也就是内存地址，指针变量是用来存放内存地址的变量
*p 表示 对变量p进行寻址
*int 表示整型指针变量，用在声明处
    var p *int
    p = &a
    *p 
    
func changeVaule(p *int){
    *p = 10
}
changeVaule(&a)
结构体指针:
    //只有一个特殊的地方，尽管b所表示的是Book1对象的内存地址，但是，在从b对应的内存地址取属性值的时候，就不是*b.title了。而是直接使用b.title，这点很特殊，它的效果就相当于Book1.title
    
普通指针与结构体指针区别：
    结构体指针不用寻址

====================================================
    type Books struct {
        title string
        author string
        subject string
        book_id int
    }
      
    func changeBook(book *Books) {
        book.title = "book1_change" //相当于*book.title
    }
      
    func main() {
        var book1 Books;
        book1.title = "book1"
        book1.author = "zuozhe"
        book1.book_id = 1
        changeBook(&book1)   //将book1这个对象的内存地址传进去，
        fmt.Println(book1)
    }
====================================================
    func (this *Server) Start() { 
        this.title = "book"   //this表示实例，相当于*this
    }


go mod init
    module中的main文件调用package：
        package 中不要有go.mod文件，package指文件夹，文件夹里的go文件的第一行package 包名，包名最好与go文件所在的文件夹名一致。
        package中当有go.mod文件，会认为是个module，导包会出错
    自己项目（mudule）中引用其他mudule：
        https://www.cnblogs.com/oxspirt/p/14774584.html


interface{}
    nums := []interface{}{1, 2, 3, 4}
    ------------------------------------
    动态初始化
        strs := []string{"first", "second"}
        names := make([]interface{}, len(strs))
        for i, s := range strs {
            names[i] = s
        }
        ------------------------------------
        var names []interface{}
        names = append(names, "first")
        names = append(names, "second")
        或这个:
        var names []interface{}
        names = append(names, "first", "second")
        ------------------------------------
        dest := []interface{}{
            new(string),  //内置函数new，new按指定类型长度分配零值内存，返回指针
            new(uint32),
        }
        
    ------------------------------------
    函数的不定参定义和调用
        func sum(arr ...interface{}) {
            for _, data := range arr {
                mylog.Debug.Println(data)
            }
        }

        func main() {
            nums := []interface{}{1, 2, 3, 4}
            sum(nums...)
        }

打印类型，格式化字符串
    fmt.Printf("%T", subsCodes) //打印类型
    fmt.Println(len(subsCodes))
    fmt.Printf("%d", len(subsCodes))

time.Sleep(time.Second)
time.Sleep(time.Second*5)





