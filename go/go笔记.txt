go build [包名]/[文件]  
    如果有main函数，才会生成可执行文件
    工作目录下生成可执行文件，如果有-o 会生成指定名称的可执行文件，没有-o，会生成默认的可执行文件， 生成的可执行文件比较大，能在没有go环境的下运行
    
go install  将可执行文件放置在$go/bin
go run main.go
go mod init xxx

xx.mod
    require "liwenzhou.com/q1mi/p2" v0.0.0
    replace "liwenzhou.com/q1mi/p2" => "../p2"

go跨平台编译:

第三方包下载的路径问题
    当GO111MODULE=on时，下载到$GOPATH/pkg/mod下,
    如go get github.com/astaxie/beego， 就安装到$GOPATH\pkg\mod\github.com\astaxie\beego,同时其依赖包也会安装到$GOPATH\pkg\mod\github.com下
    
同一个包下调用不同文件
    如main包下有a.go, b.go
    go mod init main  //执行go run . 需要是个mudule
    go run .  //需编译a.go 和b.go  会执行main函数，不需要a.go中import b.go的变量



windows
    set PKG_CONFIG_PATH=E:\company\project\go-aci
linux
    export PKG_CONFIG_PATH=/root/go-aci
    go env -w GOPROXY=https://goproxy.cn,direct
    
    
    
开启GO11MODULE=on 后，go get 安装的包将到 go/pkg下
go get -m [packages]会将下载的依赖包放到GOPATH/pkg/mod目录下

下载个>1.14版本go
    设置代理，GOPROXY=https://goproxy.io,direct，可以打开任意文件夹，在vscode里打开
    go mod init xxx

每行可以不加分号
" { "不能单独一行
:= 只能函数内使用
fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b ); 变量类型

动态数组  
    myarry [4]int   声明
    myarry := [4]int{1，2，3，4} 
    在函数调用时是引用传递
静态数组  
    myarry []int   声明
    myarry := []int{1，2，3，4}
    在函数调用时是值传递，传参是值拷贝
    
指针用于存放地址，指针也就是内存地址，指针变量是用来存放内存地址的变量
*p 表示 对变量p进行寻址
*int 表示整型指针变量，用在声明处
    var p *int
    p = &a
    *p 
    
func changeVaule(p *int){
    *p = 10
}
changeVaule(&a)
结构体指针:
    //只有一个特殊的地方，尽管b所表示的是Book1对象的内存地址，但是，在从b对应的内存地址取属性值的时候，就不是*b.title了。而是直接使用b.title，这点很特殊，它的效果就相当于Book1.title
    
普通指针与结构体指针区别：
    结构体指针不用寻址

====================================================
    type Books struct {
        title string
        author string
        subject string
        book_id int
    }
      
    func changeBook(book *Books) {
        book.title = "book1_change" //相当于*book.title
    }
      
    func main() {
        var book1 Books;
        book1.title = "book1"
        book1.author = "zuozhe"
        book1.book_id = 1
        changeBook(&book1)   //将book1这个对象的内存地址传进去，
        fmt.Println(book1)
    }
====================================================
    func (this *Server) Start() { 
        this.title = "book"   //this表示实例，相当于*this
    }


go mod init
    module中的main文件调用package：
        package 中不要有go.mod文件，package指文件夹，文件夹里的go文件的第一行package 包名，包名最好与go文件所在的文件夹名一致。
        package中当有go.mod文件，会认为是个module，导包会出错
    自己项目（mudule）中引用其他mudule：
        https://www.cnblogs.com/oxspirt/p/14774584.html


interface{}
    nums := []interface{}{1, 2, 3, 4}
    ------------------------------------
    动态初始化
        strs := []string{"first", "second"}
        names := make([]interface{}, len(strs))
        for i, s := range strs {
            names[i] = s
        }
        ------------------------------------
        var names []interface{}
        names = append(names, "first")
        names = append(names, "second")
        或这个:
        var names []interface{}
        names = append(names, "first", "second")
        ------------------------------------
        dest := []interface{}{
            new(string),  //内置函数new，new按指定类型长度分配零值内存，返回指针
            new(uint32),
        }
        
    ------------------------------------
    函数的不定参定义和调用
        func sum(arr ...interface{}) {
            for _, data := range arr {
                mylog.Debug.Println(data)
            }
        }

        func main() {
            nums := []interface{}{1, 2, 3, 4}
            sum(nums...)
        }

打印类型，格式化字符串
    fmt.Printf("%T", subsCodes) //打印类型
    fmt.Println(len(subsCodes))
    fmt.Printf("%d", len(subsCodes))

time.Sleep(time.Second)
time.Sleep(time.Second*5)

================指针举例=============================
type User struct {
    id string
    Name string
}
&User{}
user := User{id:1, Name:"xx"}
&user或者User{id:1, Name:"xx"}
&User{}和&user都是指针类型

var z *string
z = new(string) //指针使用前必须现初始话，赋予个地址
*z = "xxx"
fmt.Println(*z)
fmt.Println(z)
====================================================
errors.Is(result.Error, gorm.ErrRecordNotFound)

================测试================================
go test -v -run TestQuery4_1 orm_test.go   运行orm_test.go文件中TestQuery4_1测试函数
go test -v                                 运行当前工作目录下所有_test.go文件

