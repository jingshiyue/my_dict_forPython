http://www.liujiangblog.com/course/django/89

django-admin startproject mysite
python manage.py runserver     127.0.0.1:8000
python manage.py startapp polls

from django.http import HttpResponse
from django.urls import path,include

python manage.py migrate    一旦更改了模型，就需要迁移数据库，如加了字段
    migrate命令将遍历INSTALLED_APPS设置中的所有项目，在数据库中创建对应的表，并打印出每一条动作信息。如果你感兴趣，可以在你的数据库命令行下输入：\dt (PostgreSQL)、 SHOW TABLES;(MySQL)或 .schema(SQLite) 来列出 Django 所创建的表。
    提示：对于极简主义者，你完全可以在INSTALLED_APPS内注释掉任何或者全部的Django提供的通用应用。这样，migrate也不会再创建对应的数据表。

python manage.py makemigrations polls     产生migrants文件，为改动创建迁移记录
python manage.py sqlmigrate polls 0001    查看转换的sql语句
python manage.py migrate  将操作同步到数据库 之所以要将创建和实施迁移的动作分成两个命令两步走是因为你也许要通过版本控制系统（例如github，svn）提交你的项目代码，如果没有一个中间过程的保存文件（migrations），那么github如何知道以及记录、同步、实施你所进行过的模型修改动作呢？毕竟，github不和数据库直接打交道，也没法和你本地的数据库通信。但是分开之后，你只需要将你的migration文件（例如上面的0001）上传到github，它就会知道一切
python manage.py shell            
    
python manage.py createsuperuser    
    
在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：CREATE DATABASE database_name;。Django不会自动帮你做这一步工作。
LANGUAGE_CODE = 'zh-hans'   中文
TIME_ZONE = 'Asia/Shanghai'  时区

在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：CREATE DATABASE database_name;。Django不会自动帮你做这一步工作。

setting.py中配置mysql数据库：
    import pymysql         # 一定要添加这两行！通过pip install pymysql！
    pymysql.install_as_MySQLdb()

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'mysite',
            'HOST': '192.168.1.1',
            'USER': 'root',
            'PASSWORD': 'pwd',
            'PORT': '3306',
        }
    }
        
INSTALLED_APPS = [
    'polls.apps.PollsConfig',  #自己加的app，注意加逗号隔开
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]        
        
        
        
        
        
        
主url：
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('polls/',include('polls.urls'))#include里要加引号！！！！！
]
app url：
    urlpatterns = [
    path('', views.index, name='index'),
]

path()方法：
    路由系统中最重要的path()方法可以接收4个参数，其中2个是必须的：route和view，以及2个可选的参数：kwargs和name。
    route：
    route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项，然后执行该条目映射的视图函数或下级路由，其后的条目将不再继续匹配。因此，url路由的编写顺序非常重要！
    需要注意的是，route不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/时，它会尝试匹配 myapp/。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。

    view：
    view指的是处理当前url请求的视图函数。当Django匹配到某个路由条目时，自动将封装的HttpRequest对象作为第一个参数，被“捕获”的参数以关键字参数的形式，传递给该条目指定的视图view。

    kwargs：
    任意数量的关键字参数可以作为一个字典传递给目标视图。

    name：
    对你的URL进行命名，让你能够在Django的任意处，尤其是模板内显式地引用它。这是一个非常强大的功能，相当于给URL取了个全局变量名，不会将url匹配地址写死。
    
render()
    from django.shortcuts import render
    return render(request, 'polls/index.html', context)    render()函数的第一个位置参数是请求对象（就是view函数的第一个参数），第二个位置参数是模板。还可以有一个可选的第三参数，一个字典，包含需要传递给模板的数据。最后render函数返回一个经过字典数据渲染过的模板封装而成的HttpResponse对象
    
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li> #可在模板中嵌套使用 detail是url的name，question.id是detail函数里的一个参数。
    反向寻址
    Django会在polls.urls文件中查找name='detail'的url，具体的就是下面这行：
    path('<int:question_id>/', views.detail, name='detail'),
    
URL names的命名空间:
    app_name = 'polls'  #在polls/urls.py文件的开头部分
    <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>  #模板

    
管理员注册：
    打开polls/admin.py文件，加入下面的内容：

    from django.contrib import admin
    from .models import Question

    admin.site.register(Question)
	
django虚拟环境（windows）：
	1、pip install virtualenv   安装包
	2、C:\Users\Administrator\Desktop\demo>virtualenv blogproject_env   创建文件夹
	3、C:\Users\Administrator\Desktop\demo\blogproject_env\Scripts>activate   进入.\blogproject_env\Scripts，运行activate文件激活环境
	4、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env\Scripts>  已经激活
	5、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env\Scripts>pip install django==1.10.6   安装指定版本 django
	
	6、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env>django-admin startproject blogproject 创建项目
	7、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py runserver 运行项目
	8、C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py startapp blog 创建应用
	9、	数据更新到数据库中，先setting.py里添加进app（感觉这是创建表？）
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py makemigrations  
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py migrate
	10、进入manage shell界面操作表里数据（也可浏览器进去admin界面操作）：
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py shell
		增：
			>>> from blog.models import Category, Tag, Post
			>>> c = Category(name='category test')
			>>> c.save()
		查：
			>>> Category.objects.all()
		改：
			>>> c = Category.objects.get(name='category test')
			>>> c.name = 'category test new'
			>>> c.save()
		删：
			>>> p = Post.objects.get(title='title test')
			>>> p.delete()
		
		
		
	创建超级用户：	
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py createsuperuser
		
		
category = models.ForeignKey(Category) #写在“一” 的model里，文章和分类关系是：一对多，所以该语句写在文章类中
tags = models.ManyToManyField(Tag, blank=True)  #多对多，文章和分类关系是：多对多，写在哪个类中？
多对多的关系无法再像一对多的关系中的例子一样在文章数据库表加一列 分类 ID 来关联了，因此需要额外建一张表来记录文章和标签之间的关联
Django 内置的模板标签
用 {{ }} 包裹起来的叫做模板变量
用 {% %} 包裹起来的叫做模板标签
{% extends 'base.html' %}
{% block main %}{% endblock main %} 
safe 过滤器，{{ post.body|safe }}
母模板里要包含所有的block块，子模版里可以不用母模板里所有block，字模板里只有{% extends 'base.html' %} 和block。
{% get_recent_posts as recent_post_list %} get_recent_posts 是自定义的模板标签，最上面要加模板文件加载进来{% load blog_tags %}   #}
<a href="{{ post.get_absolute_url }}">{{ post.title }}</a>



有时候按 F5 刷新后页面还是很乱，这可能是因为浏览器缓存了之前的结果。按 Shift + F5（有些浏览器可能是 Ctrl + F5）强制刷新浏览器页面即可。
为了能在模板中使用 {% static %} 模板标签，别忘了在最顶部 {% load staticfiles %} 。static 模板标签位于 staticfiles 模块中，只有通过 load 模板标签将该模块引入后，才能在模板中使用 {% static %} 标签。
而 /static/ 前缀是我们在 settings.py 文件中通过 STATIC_URL = '/static/' 指定的
{% empty %} 的作用是当 post_list 为空，即数据库里没有文章时显示 {% empty %} 下面的内容，最后我们用 {% endfor %} 告诉 Django 循环在这里结束了
例如这里的 {{ post.pk }}（pk 是 primary key 的缩写
[0-9]+ 表示一位或者多位数。此外这里 (?P<pk>[0-9]+) 表示命名捕获组，其作用是从用户访问的 URL 里把括号内匹配的字符串捕获并作为关键字参数传给其对应的视图函数 detail
app_name='blog' 告诉 Django 这个 urls.py 模块是属于 blog 应用的，这种技术叫做视图函数命名空间。一些第三方应用中也可能有叫 index、detail 的视图函数，那么怎么把它们区分开来，防止冲突呢？方法就是通过 app_name 来指定命名空间
分为：级联删除、不作为、报错、设置为Null值、设置为default值、自定义一个值
注意到 URL 配置中的 url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail') ，我们设定的 name='detail' 在这里派上了用场。
看到这个 reverse 函数，它的第一个参数的值是 'blog:detail'，意思是 blog 应用下的 name=detail 的函数，由于我们在上面通过 app_name = 'blog' 
告诉了 Django 这个 URL 模块是属于 blog 应用的，因此 Django 能够顺利地找到 blog 应用下 name 为 detail 的视图函数，于是 reverse 
函数会去解析这个视图函数对应的 URL，我们这里 detail 对应的规则就是 post/(?P<pk>[0-9]+)/ 这个正则表达式，而正则表达式部分会被后面传入的参数 pk 替换，
所以，如果 Post 的 id（或者 pk，这里 pk 和 id 是等价的） 是 255 的话，
那么 get_absolute_url 函数返回的就是 /post/255/ ，这样 Post 自己就生成了自己的 URL。
这里 block 也是一个模板标签，其作用是占位。比如这里的 {% block main %}{% endblock main %} 是一个占位框，main 是我们给这个 block 取的名字
Markdown 是一种 HTML 文本标记语言，只要遵循它约定的语法格式，Markdown 的渲染器就能够把我们写的文章转换为标准的 HTML 文档
但是由于这里作为函数的参数列表，所以 Django 要求我们把点替换成了两个下划线，即 created_time__year
redirect 既可以接收一个 URL 作为参数，也可以接收一个模型的实例作为参数（例如这里的 post）。如果接收一个模型的实例，那么这个实例必须实现了 get_absolute_url 方法，这样 redirect 会根据 get_absolute_url 方法返回的 URL 值进行重定向
另外我们使用了 post.comment_set.all() 来获取 post 对应的全部评论。 Comment 和Post 是通过 ForeignKey 关联的，回顾一下我们当初获取某个分类 cate 下的全部文章时的代码：Post.objects.filter(category=cate)。这里 post.comment_set.all() 也等价于 Comment.objects.filter(post=post)，即根据 post 来过滤该 post 下的全部评论。但既然我们已经有了一个 Post 模型的实例 post（它对应的是 Post 在数据库中的一条记录），那么获取和 post 关联的评论列表有一个简单方法，即调用它的 xxx_set 属性来获取一个类似于 objects 的模型管理器，然后调用其 all 方法来返回这个 post 关联的全部评论。 其中 xxx_set 中的 xxx 为关联模型的类名（小写）。
例如 Post.objects.filter(category=cate) 也可以等价写为 cate.post_set.all()。
{{ form.name }}、{{ form.email }}、{{ form.url }} 等将自动渲染成表单控件，例如 <input> 控件。

{{ form.name.errors }}、{{ form.email.errors }} 等将渲染表单对应字段的错误（如果有的话），例如用户 email 格式填错了，那么 Django 会检查用户提交的 email 的格式，然后将格式错误信息保存到 errors 中，模板便将错误信息渲染显示。
Django 允许我们在 models.Model 的子类里定义一个 Meta 的内部类，这个内部类通过指定一些属性来规定这个类该有的一些特性 比如 
class Meta:
	ordering = ['-created_time', 'title'] ，那么首先依据 created_time 排序，如果 created_time 相同，则再依据 title 排序

(blogproject_env) C:\Users\yangxg\Workspace\blogproject>
pip freeze > requirements.txt
这时项目根目录下会生成了一个 requirements.txt 的文本文件，其内容记录了项目的全部依赖。



templates/base.html
 
{% for date in date_list %}
<li>
  <a href="{% url 'blog:archives' date.year date.month %}">
    {{ date.year }} 年 {{ date.month }} 月
  </a>
</li>
{% endfor %}
这里 {% url %} 这个模板标签的作用是解析视图函数 blog:archives 对应的 URL 模式，并把 URL 模式中的年和月替换成 date.year，date.month 的值。例如 blog:archives 表示 blog 应用下的 archives 函数，这个函数对应的 URL 模式为 ^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$，假设 date.year=2017，date.month=5，那么 {% url 'blog:archives' date.year date.month %} 模板标签返回的值为/archives/2017/5/。
为什么要使用 {% url %} 模板标签呢？事实上，我们把超链接的 href 属性设置为 /archives/{{ date.year }}/{{ date.month }}/ 同样可以达到目的，但是这种写法是硬编码的。虽然现在 blog:archives 视图函数对应的 URL 模式是这种形式，但是如果哪天这个模式改变了呢？如果使用了硬编码的写法，那你需要把每一处 /archives/{{ date.year }}/{{ date.month }}/ 修改为新的模式。但如果使用了 {% url %} 模板标签，则不用做任何修改。


reverse('blog:detail', kwargs={'pk': self.pk})
	注意到 URL 配置中的 url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail') ，我们设定的 name='detail' 在这里派上了用场。看到这个 reverse 函数，它的第一个参数的值是 'blog:detail'，意思是 blog 应用下的 name=detail 的函数，由于我们在上面通过 app_name = 'blog' 告诉了 Django 这个 URL 模块是属于 blog 应用的，因此 Django 能够顺利地找到 blog 应用下 name 为 detail 的视图函数，于是 reverse 函数会去解析这个视图函数对应的 URL，我们这里 detail 对应的规则就是 post/(?P<pk>[0-9]+)/ 这个正则表达式，而正则表达式部分会被后面传入的参数 pk 替换，所以，如果 Post 的 id（或者 pk，这里 pk 和 id 是等价的） 是 255 的话，那么 get_absolute_url 函数返回的就是 /post/255/ ，这样 Post 自己就生成了自己的 URL
render(request, 'blog/detail.html', context={'post': post})

pip install markdown
pip install Pygments
pip install pytz

{{ var | filter: arg }}
{% get_categories as category_list %}
	{% for category in category_list %}
	<li>
		<a href="#">{{ category.name }} <span class="post-count">(13)</span></a>
	</li>
	{% empty %}
	暂无分类！
	{% endfor %}
								

自定义标签模板：
	1、blog应用下创建templatetags文件夹
	2、templatetags文件夹下 创建blog_tags.py
	3、blog_tags.py中加入如下：
		from ..models import Post,Category
		from django import template
		register = template.Library()

		@register.simple_tag
		def get_recent_posts(num=5):
			return Post.objects.all().order_by('-created_time')[:num]
	4、setting.py里注册模板blog_tags
			TEMPLATES = [
			{
				'BACKEND': 'django.template.backends.django.DjangoTemplates',
				'DIRS': [os.path.join(BASE_DIR, 'templates')],
				'APP_DIRS': True,
				'OPTIONS': {
					'context_processors': [
						'django.template.context_processors.debug',
						'django.template.context_processors.request',
						'django.contrib.auth.context_processors.auth',
						'django.contrib.messages.context_processors.messages',
					],
					'libraries': {
						'blog_tags': 'blog.templatetags.blog_tags',    
					}
				},
			},
		]

yangxg@localhost:~/sites/demo.zmrenwu.com$ ls
django-blog-tutorial（项目）  env（在com里面创建虚拟环境）

yangxg@localhost:~/sites/demo.zmrenwu.com$ virtualenv --python=python3 env
virtualenv --python=python3.7 env


sudo service nginx start
conda create --name nlp python=3.6
# 进入conda创建的环境nlp
source activate nlp  #linux系统里激活
activate nlp  #windows系统里激活
# 退出conda创建的环境nlp
source deactivate

conda install tensorflow-gpu
conda uninstall numpy

5.安装/删除包

conda install tensorflow-gpu
conda uninstall numpy

6.查看现有的虚拟环境列表

conda info -e
# 查看当前环境的详情
conda info




/etc/init.d/nginx configtest 检查配置，不报错
/etc/init.d/nginx restart 重启nginx
sudo tree /etc/nginx
/etc/nginx				  #nginx的配置文件主目录
/etc/nginx/nginx.conf		#nginx的主配置文件，全局配置.

/etc/nginx/conf.d		  #附加配置文件目录
/etc/nginx/conf.d/default.conf  #nginx初始提供的默认子配置文件

/var/cache/nginx							#nginx缓存相关的路径
/var/log/nginx								#nginx的日志记录的路径
service nginx reload 重新加载配置
/var/www/html为网站文件存放的地方, 默认只有Nginx欢迎页面, 可以通过改变Nginx配置文件的方式来修改这个位置.
3. /etc/nginx/sites-available
这个目录存储每一个网站的"server blocks", Nginx通常不会使用这些配置, 除非它们被链接到sites-enabled目录. 一般所有的server block配置都在这个目录中设置, 然后软链接到别的目录.
4. /etc/nginx/sites-enabled
这个目录存储生效的"server blocks"配置. 通常, 这个配置都是链接到sites-available目录中的配置文件.只有在 sites-enabled 目录下的配置文件才能够真正被用户访问
5. /etc/nginx/snippets
这个目录主要可以包含在其它Nginx配置文件中的配置片段, 重复的配置都可以重构为配置片段.
1. /var/log/nginx/access.log
每一个访问请求都会默认记录在这个文件中, 除非你做了其它设置.
2. /var/log/nginx/error.log
任何Nginx的错误信息都会记录到这个文件中.

~/sites/demo.zmrenwu.com/django-blog-tutorial$ sudo ln -s /etc/nginx/sites-available/myblog.com /etc/nginx/sites-enabled/myblog.com

gunicorn启动django
(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ gunicorn -w 4 -b 0.0.0.0:8000 blogproject.wsgi:application （要进去其作目录下运行该命令，不然启动不成功）

媒体文件：用户上传的文件
静态文件：css,js，image等
开发环境：使用django内置服务器处理静态文件
生产环境：使用apache2/nginx服务器处理静态文件映射


开发环境下，是在各自的app下创建static文件夹，setting.py中 DEBUG = True，是通过使用django内置服务器访问静态文件
在生成环境中，集中存放静态资源有利于使用Lighttpd/Nginx托管静态资源。而生产环境一般是把静态文件放在项目根目录下的static目录（STATIC_ROOT = os.path.join(BASE_DIR, 'static')）下，python manage.py collectstatic收集所有已安装的APP的静态文件到根目录的
STATIC_URL = '/statica/'  #模板渲染时 url静态文件路径的前缀,注意前缀家的是相对路径

shift+F5 强制浏览器清空缓存，很有用哦。浏览器往往会缓存静态文件

sftp://root0@175.168.1.147/home/root0/sites/myblog.com/blogproject/static/static/blog/css/bootstrap.min.css



Nginx配置
	1、/etc/nginx/sites-available/ 目录下新建一个配置文件，，文件名我一般就设置为域名
	2、建立软连接到sites-enabled  ln -s /etc/nginx/sites-available/myblog.com /etc/nginx/sites-enabled/myblog.com							
								
								
								
server {
    charset utf-8;
    listen 8001;
    server_name 175.168.1.147;

    location /static {
        alias /home/root0/sites/myblog.com/blogproject/static;
        #root /home/root0/sites/myblog.com/blogproject/static
    }


    location / {
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/175.168.1.147;
    }
}


svn://192.168.5.12/Develop/Export/SecurityCompetitionScoreDisplay


######启动Nginx服务
[root@typecodes ~]# service nginx start
######停止Nginx服务
[root@typecodes ~]# service nginx stop
######重启Nginx服务
[root@typecodes ~]# service nginx restart
######Nginx服务的状态
[root@typecodes ~]# service nginx status
######在Nginx服务启动的状态下，重新加载nginx.conf这个配置文件
[root@typecodes ~]# service nginx reload #不检查配置文件是否错误
sudo nginx -s reload #要检查配置文件是否错误，建议用这个替换



1.Ubuntu下安装Nginx比较简单
    sudo apt-get update
    sudo apt-get install nginx
 

2.Ubuntu下卸载，稍不注意就会入坑
	sudo service nginx stop  #先停掉nginx
    sudo apt-get remove nginx nginx-common # 卸载删除除了配置文件以外的所有文件。
    sudo apt-get purge nginx nginx-common # 卸载所有东东，包括删除配置文件。
    sudo apt-get autoremove # 在上面命令结束后执行，主要是卸载删除Nginx的不再被使用的依赖包。
    sudo apt-get remove nginx-full nginx-common #卸载删除两个主要的包。

项目总结：
	post_list = Post.objects.all().order_by('-created_time')
	return render(request, 'blog/index.html', context={'post_list': post_list})
	def __str__(self):
			return self.title
	class Meta:
			ordering = ['-created_time']
	title = models.CharField(max_length=70)
	body = models.TextField() #大段文本
	created_time = models.DateTimeField()
	modified_time = models.DateTimeField()
	
    excerpt = models.CharField(max_length=200, blank=True) # 指定 CharField 的 blank=True 参数值后就可以允许空值了。
	category = models.ForeignKey(Category,on_delete=models.CASCADE)
    tags = models.ManyToManyField(Tag, blank=True)
	views = models.PositiveIntegerField(default=0)  #PositiveIntegerField？
	return reverse('blog:detail', kwargs={'pk': self.pk})
	
	def increase_views(self):
        self.views += 1
        self.save(update_fields=['views'])
	from django.shortcuts import render, get_object_or_404
	import markdown
	return render(request, 'blog/index.html', context={'post_list': post_list})
	
	post.body = markdown.markdown(post.body,
                                  extensions=[
                                      'markdown.extensions.extra',
                                      'markdown.extensions.codehilite',
                                      'markdown.extensions.toc',
                                  ])
								  
	comment_list = post.comment_set.all()  #帅选出comment
	post_list = Post.objects.filter(created_time__year=year,
                                    created_time__month=month
                                    ).order_by('-created_time')

	cate = get_object_or_404(Category, pk=pk)
	url = models.URLField(blank=True)
	email = models.EmailField(max_length=255)
	created_time = models.DateTimeField(auto_now_add=True)  #时间自动生成
	url(r'^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$', views.archives, name='archives'),
	
	class PostAdmin(admin.ModelAdmin):
    list_display = ['title', 'created_time', 'modified_time', 'category', 'author']
	admin.site.register(Post)
	admin.site.register(Category)
	admin.site.register(Tag)

	urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'', include('blog.urls')),
    url(r'', include('comments.urls')),
]
	if request.method == 'POST':
	if form.is_valid():
	
	# 将评论和被评论的文章关联起来。
    comment.post = post  ????
	
	{% extends 'base.html' %}
	{% block main %} #main是block名字，可替换成任意名字
	{% endblock main %}
	<form action="{% url 'comments:post_comment' post.pk %}" method="post" class="comment-form">
	{% for post in post_list %}
	{% empty %}
	{% endfor %}
	{% load staticfiles %}
	<script src="{% static 'blog/js/jquery-2.1.3.min.js' %}"></script>
    <script src="{% static 'blog/js/bootstrap.min.js' %}"></script>
	models.Model 自带save方法吗？super(Post, self).save(*args, **kwargs)
	url(r'^$', views.IndexView.as_view(), name='index'),
	return super(CategoryView, self).get_queryset().filter(category=cate)
	from django.views.generic import ListView, DetailView
	from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
	
    {% if is_paginated %}
      {% if page_obj.has_previous %}
      {% endif %}

      {% if page_obj.has_next %}
      {% endif %}
    {% endif %}

	{% if is_paginated %}
	<div class="pagination-simple">
	  <!-- 如果当前页还有上一页，显示一个上一页的按钮 -->
	  {% if page_obj.has_previous %}
		<a href="?page={{ page_obj.previous_page_number }}">上一页</a>
	  {% endif %}
	  <!-- 显示当前页面信息 -->
	  <span class="current">第 {{ page_obj.number }} 页 / 共 {{ paginator.num_pages }} 页</span>
	  <!-- 如果当前页还有下一页，显示一个下一页的按钮 -->
	  {% if page_obj.has_next %}
		<a href="?page={{ page_obj.next_page_number }}">下一页</a>
	  {% endif %}
	</div>
	{% endif %}
	from django.db.models.aggregates import Count
	tag = get_object_or_404(Tag, pk=self.kwargs.get('pk'))

	from blog.feeds import AllPostsRssFeed
	urlpatterns = [
    url(r'^all/rss/$', AllPostsRssFeed(), name='rss'),
]	
	 {{ post.toc|safe }} safe 标签防止 Django 对其转义
	 django.utils.text 中的 slugify 方法，该方法可以很好地处理中文。
	 from django.utils.text import slugify
	from markdown.extensions.toc import TocExtension
	 md = markdown.Markdown(extensions=[
            'markdown.extensions.extra',
            'markdown.extensions.codehilite',
            # 'markdown.extensions.toc', #toc 目录
            TocExtension(slugify=slugify),
        ])
	from django.utils.text import slugify
	from django.db.models import Q
	
	<form role="search" method="get" id="searchform" action="{% url 'blog:search' %}">   #form get提交
        <input type="search" name="q" placeholder="搜索" required>
        <button type="submit"><span class="ion-ios-search-strong"></span></button>
    </form>

	def search(request):
		q = request.GET.get('q')
		error_msg = ''

		if not q:
			error_msg = "请输入关键词"
			return render(request, 'blog/index.html', {'error_msg': error_msg})

		post_list = Post.objects.filter(Q(title__icontains=q) | Q(body__icontains=q))
		return render(request, 'blog/index.html', {'error_msg': error_msg,
                                               'post_list': post_list})
											
		django haystack 的规定。要相对某个 app 下的数据进行全文检索，就要在该 app 下创建一个 search_indexes.py 文件，


	try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")




