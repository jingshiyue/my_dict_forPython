http://www.liujiangblog.com/course/django/89
https://djangopackages.org/ 
django-admin startproject mysite
python manage.py runserver 127.0.0.1:8000
python manage.py startapp polls

from django.http import HttpResponsefrom django.urls import path,include

python manage.py migrate    一旦更改了模型，就需要迁移数据库，如加了字段
    migrate命令将遍历INSTALLED_APPS设置中的所有项目，在数据库中创建对应的表，并打印出每一条动作信息。如果你感兴趣，可以在你的数据库命令行下输入：\dt (PostgreSQL)、 SHOW TABLES;(MySQL)或 .schema(SQLite) 来列出 Django 所创建的表。
    提示：对于极简主义者，你完全可以在INSTALLED_APPS内注释掉任何或者全部的Django提供的通用应用。这样，migrate也不会再创建对应的数据表。

python manage.py makemigrations polls     产生migrants文件，为改动创建迁移记录
python manage.py sqlmigrate polls 0001    查看转换的sql语句
python manage.py migrate  将操作同步到数据库 之所以要将创建和实施迁移的动作分成两个命令两步走是因为你也许要通过版本控制系统（例如github，svn）提交你的项目代码，如果没有一个中间过程的保存文件（migrations），那么github如何知道以及记录、同步、实施你所进行过的模型修改动作呢？毕竟，github不和数据库直接打交道，也没法和你本地的数据库通信。但是分开之后，你只需要将你的migration文件（例如上面的0001）上传到github，它就会知道一切
python manage.py shell            
    
python manage.py createsuperuser    
    
在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：CREATE DATABASE database_name;。Django不会自动帮你做这一步工作。
LANGUAGE_CODE = 'zh-hans'   中文
TIME_ZONE = 'Asia/Shanghai'  时区

在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：CREATE DATABASE database_name;。Django不会自动帮你做这一步工作。

setting.py中配置mysql数据库：
    import pymysql         # 一定要添加这两行！通过pip install pymysql！
    pymysql.install_as_MySQLdb()

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'mysite',
            'HOST': '192.168.1.1',
            'USER': 'root',
            'PASSWORD': 'pwd',
            'PORT': '3306',
        }
    }
        
INSTALLED_APPS = [
    'polls.apps.PollsConfig',  #自己加的app，注意加逗号隔开
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]        
        
        
        
        
        
        
主url：
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('polls/',include('polls.urls'))#include里要加引号！！！！！
]
app url：
    urlpatterns = [
    path('', views.index, name='index'),
]

path()方法：
    路由系统中最重要的path()方法可以接收4个参数，其中2个是必须的：route和view，以及2个可选的参数：kwargs和name。
    route：
    route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项，然后执行该条目映射的视图函数或下级路由，其后的条目将不再继续匹配。因此，url路由的编写顺序非常重要！
    需要注意的是，route不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/时，它会尝试匹配 myapp/。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。

    view：
    view指的是处理当前url请求的视图函数。当Django匹配到某个路由条目时，自动将封装的HttpRequest对象作为第一个参数，被“捕获”的参数以关键字参数的形式，传递给该条目指定的视图view。

    kwargs：
    任意数量的关键字参数可以作为一个字典传递给目标视图。

    name：
    对你的URL进行命名，让你能够在Django的任意处，尤其是模板内显式地引用它。这是一个非常强大的功能，相当于给URL取了个全局变量名，不会将url匹配地址写死。
    
render()
    from django.shortcuts import render
    return render(request, 'polls/index.html', context)    render()函数的第一个位置参数是请求对象（就是view函数的第一个参数），第二个位置参数是模板。还可以有一个可选的第三参数，一个字典，包含需要传递给模板的数据。最后render函数返回一个经过字典数据渲染过的模板封装而成的HttpResponse对象
    
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li> #可在模板中嵌套使用 detail是url的name，question.id是detail函数里的一个参数。
    反向寻址
    Django会在polls.urls文件中查找name='detail'的url，具体的就是下面这行：
    path('<int:question_id>/', views.detail, name='detail'),
    
URL names的命名空间:
    app_name = 'polls'  #在polls/urls.py文件的开头部分
    <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>  #模板

    
管理员注册：
    打开polls/admin.py文件，加入下面的内容：

    from django.contrib import admin
    from .models import Question

    admin.site.register(Question)
	
django虚拟环境（windows）：
	1、pip install virtualenv   安装包
	2、C:\Users\Administrator\Desktop\demo>virtualenv blogproject_env   创建文件夹
	3、C:\Users\Administrator\Desktop\demo\blogproject_env\Scripts>activate   进入.\blogproject_env\Scripts，运行activate文件激活环境
	4、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env\Scripts>  已经激活
	5、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env\Scripts>pip install django==1.10.6   安装指定版本 django
	
	6、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env>django-admin startproject blogproject 创建项目
	7、(blogproject_env) C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py runserver 运行项目
	8、C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py startapp blog 创建应用
	9、	数据更新到数据库中，先setting.py里添加进app（感觉这是创建表？）
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py makemigrations  
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py migrate
	10、进入manage shell界面操作表里数据（也可浏览器进去admin界面操作）：
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py shell
		增：
			>>> from blog.models import Category, Tag, Post
			>>> c = Category(name='category test')
			>>> c.save()
		查：
			>>> Category.objects.all()
		改：
			>>> c = Category.objects.get(name='category test')
			>>> c.name = 'category test new'
			>>> c.save()
		删：
			>>> p = Post.objects.get(title='title test')
			>>> p.delete()
		
		
		
	创建超级用户：	
		C:\Users\Administrator\Desktop\demo\blogproject_env\blogproject>python manage.py createsuperuser
		
		
category = models.ForeignKey(Category) #写在“一” 的model里，文章和分类关系是：一对多，所以该语句写在文章类中
tags = models.ManyToManyField(Tag, blank=True)  #多对多，文章和分类关系是：多对多，写在哪个类中？
多对多的关系无法再像一对多的关系中的例子一样在文章数据库表加一列 分类 ID 来关联了，因此需要额外建一张表来记录文章和标签之间的关联
Django 内置的模板标签
用 {{ }} 包裹起来的叫做模板变量
用 {% %} 包裹起来的叫做模板标签
{% extends 'base.html' %}
{% block main %}{% endblock main %} 
safe 过滤器，{{ post.body|safe }}
母模板里要包含所有的block块，子模版里可以不用母模板里所有block，字模板里只有{% extends 'base.html' %} 和block。
{% get_recent_posts as recent_post_list %} get_recent_posts 是自定义的模板标签，最上面要加模板文件加载进来{% load blog_tags %}   #}
<a href="{{ post.get_absolute_url }}">{{ post.title }}</a>



有时候按 F5 刷新后页面还是很乱，这可能是因为浏览器缓存了之前的结果。按 Shift + F5（有些浏览器可能是 Ctrl + F5）强制刷新浏览器页面即可。
为了能在模板中使用 {% static %} 模板标签，别忘了在最顶部 {% load staticfiles %} 。static 模板标签位于 staticfiles 模块中，只有通过 load 模板标签将该模块引入后，才能在模板中使用 {% static %} 标签。
而 /static/ 前缀是我们在 settings.py 文件中通过 STATIC_URL = '/static/' 指定的
{% empty %} 的作用是当 post_list 为空，即数据库里没有文章时显示 {% empty %} 下面的内容，最后我们用 {% endfor %} 告诉 Django 循环在这里结束了
例如这里的 {{ post.pk }}（pk 是 primary key 的缩写
[0-9]+ 表示一位或者多位数。此外这里 (?P<pk>[0-9]+) 表示命名捕获组，其作用是从用户访问的 URL 里把括号内匹配的字符串捕获并作为关键字参数传给其对应的视图函数 detail
app_name='blog' 告诉 Django 这个 urls.py 模块是属于 blog 应用的，这种技术叫做视图函数命名空间。一些第三方应用中也可能有叫 index、detail 的视图函数，那么怎么把它们区分开来，防止冲突呢？方法就是通过 app_name 来指定命名空间
分为：级联删除、不作为、报错、设置为Null值、设置为default值、自定义一个值
注意到 URL 配置中的 url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail') ，我们设定的 name='detail' 在这里派上了用场。
看到这个 reverse 函数，它的第一个参数的值是 'blog:detail'，意思是 blog 应用下的 name=detail 的函数，由于我们在上面通过 app_name = 'blog' 
告诉了 Django 这个 URL 模块是属于 blog 应用的，因此 Django 能够顺利地找到 blog 应用下 name 为 detail 的视图函数，于是 reverse 
函数会去解析这个视图函数对应的 URL，我们这里 detail 对应的规则就是 post/(?P<pk>[0-9]+)/ 这个正则表达式，而正则表达式部分会被后面传入的参数 pk 替换，
所以，如果 Post 的 id（或者 pk，这里 pk 和 id 是等价的） 是 255 的话，
那么 get_absolute_url 函数返回的就是 /post/255/ ，这样 Post 自己就生成了自己的 URL。
这里 block 也是一个模板标签，其作用是占位。比如这里的 {% block main %}{% endblock main %} 是一个占位框，main 是我们给这个 block 取的名字
Markdown 是一种 HTML 文本标记语言，只要遵循它约定的语法格式，Markdown 的渲染器就能够把我们写的文章转换为标准的 HTML 文档
但是由于这里作为函数的参数列表，所以 Django 要求我们把点替换成了两个下划线，即 created_time__year
redirect 既可以接收一个 URL 作为参数，也可以接收一个模型的实例作为参数（例如这里的 post）。如果接收一个模型的实例，那么这个实例必须实现了 get_absolute_url 方法，这样 redirect 会根据 get_absolute_url 方法返回的 URL 值进行重定向
另外我们使用了 post.comment_set.all() 来获取 post 对应的全部评论。 Comment 和Post 是通过 ForeignKey 关联的，回顾一下我们当初获取某个分类 cate 下的全部文章时的代码：Post.objects.filter(category=cate)。这里 post.comment_set.all() 也等价于 Comment.objects.filter(post=post)，即根据 post 来过滤该 post 下的全部评论。但既然我们已经有了一个 Post 模型的实例 post（它对应的是 Post 在数据库中的一条记录），那么获取和 post 关联的评论列表有一个简单方法，即调用它的 xxx_set 属性来获取一个类似于 objects 的模型管理器，然后调用其 all 方法来返回这个 post 关联的全部评论。 其中 xxx_set 中的 xxx 为关联模型的类名（小写）。
例如 Post.objects.filter(category=cate) 也可以等价写为 cate.post_set.all()。
{{ form.name }}、{{ form.email }}、{{ form.url }} 等将自动渲染成表单控件，例如 <input> 控件。

{{ form.name.errors }}、{{ form.email.errors }} 等将渲染表单对应字段的错误（如果有的话），例如用户 email 格式填错了，那么 Django 会检查用户提交的 email 的格式，然后将格式错误信息保存到 errors 中，模板便将错误信息渲染显示。
Django 允许我们在 models.Model 的子类里定义一个 Meta 的内部类，这个内部类通过指定一些属性来规定这个类该有的一些特性 比如 
class Meta:
	ordering = ['-created_time', 'title'] ，那么首先依据 created_time 排序，如果 created_time 相同，则再依据 title 排序

(blogproject_env) C:\Users\yangxg\Workspace\blogproject>
pip freeze > requirements.txt
pip install -r requirements.txt
这时项目根目录下会生成了一个 requirements.txt 的文本文件，其内容记录了项目的全部依赖。



templates/base.html
 
{% for date in date_list %}
<li>
  <a href="{% url 'blog:archives' date.year date.month %}">
    {{ date.year }} 年 {{ date.month }} 月
  </a>
</li>
{% endfor %}
这里 {% url %} 这个模板标签的作用是解析视图函数 blog:archives 对应的 URL 模式，并把 URL 模式中的年和月替换成 date.year，date.month 的值。例如 blog:archives 表示 blog 应用下的 archives 函数，这个函数对应的 URL 模式为 ^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$，假设 date.year=2017，date.month=5，那么 {% url 'blog:archives' date.year date.month %} 模板标签返回的值为/archives/2017/5/。
为什么要使用 {% url %} 模板标签呢？事实上，我们把超链接的 href 属性设置为 /archives/{{ date.year }}/{{ date.month }}/ 同样可以达到目的，但是这种写法是硬编码的。虽然现在 blog:archives 视图函数对应的 URL 模式是这种形式，但是如果哪天这个模式改变了呢？如果使用了硬编码的写法，那你需要把每一处 /archives/{{ date.year }}/{{ date.month }}/ 修改为新的模式。但如果使用了 {% url %} 模板标签，则不用做任何修改。


reverse('blog:detail', kwargs={'pk': self.pk})
	注意到 URL 配置中的 url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail') ，我们设定的 name='detail' 在这里派上了用场。看到这个 reverse 函数，它的第一个参数的值是 'blog:detail'，意思是 blog 应用下的 name=detail 的函数，由于我们在上面通过 app_name = 'blog' 告诉了 Django 这个 URL 模块是属于 blog 应用的，因此 Django 能够顺利地找到 blog 应用下 name 为 detail 的视图函数，于是 reverse 函数会去解析这个视图函数对应的 URL，我们这里 detail 对应的规则就是 post/(?P<pk>[0-9]+)/ 这个正则表达式，而正则表达式部分会被后面传入的参数 pk 替换，所以，如果 Post 的 id（或者 pk，这里 pk 和 id 是等价的） 是 255 的话，那么 get_absolute_url 函数返回的就是 /post/255/ ，这样 Post 自己就生成了自己的 URL
render(request, 'blog/detail.html', context={'post': post})

pip install markdown
pip install Pygments
pip install pytz

{{ var | filter: arg }}
{% get_categories as category_list %}
	{% for category in category_list %}
	<li>
		<a href="#">{{ category.name }} <span class="post-count">(13)</span></a>
	</li>
	{% empty %}
	暂无分类！
	{% endfor %}
								

自定义标签模板：
	1、blog应用下创建templatetags文件夹
	2、templatetags文件夹下 创建blog_tags.py
	3、blog_tags.py中加入如下：
		from ..models import Post,Category
		from django import template
		register = template.Library()

		@register.simple_tag
		def get_recent_posts(num=5):
			return Post.objects.all().order_by('-created_time')[:num]
	4、setting.py里注册模板blog_tags
			TEMPLATES = [
			{
				'BACKEND': 'django.template.backends.django.DjangoTemplates',
				'DIRS': [os.path.join(BASE_DIR, 'templates')],
				'APP_DIRS': True,
				'OPTIONS': {
					'context_processors': [
						'django.template.context_processors.debug',
						'django.template.context_processors.request',
						'django.contrib.auth.context_processors.auth',
						'django.contrib.messages.context_processors.messages',
					],
					'libraries': {
						'blog_tags': 'blog.templatetags.blog_tags',    
					}
				},
			},
		]

yangxg@localhost:~/sites/demo.zmrenwu.com$ ls
django-blog-tutorial（项目）  env（在com里面创建虚拟环境）

yangxg@localhost:~/sites/demo.zmrenwu.com$ virtualenv --python=python3 env
virtualenv --python=python3.7 env


sudo service nginx start

###################conda###虚拟环境#######################################
1.查看现有的虚拟环境列表
	conda info -e
2.创建虚拟环境nlp，nlp为虚拟环境名字
	conda create --name nlp python=3.6
3.进入conda创建的环境nlp
	source activate nlp  #linux系统里激活
	activate nlp  #windows系统里激活
4.退出conda创建的环境nlp
	source deactivate
5.安装/删除包
	conda install tensorflow-gpu
	conda uninstall numpy
	pip install xxx (windows)
	
pip install django==2.2
pycharm里创建django项目，会自动下载安装与python版本匹配的最新版的django包，如果不需要这版本的django包，可以手动更改其版本
建议先用终端命令行创建好虚拟环境，然后用pycharm创建项目时候，选择对应虚拟环境里的解释器
pycharm设置默认浏览器为cherom
在Pycharm中，没有可以创建app的图形化按钮，需要在下方的Terminal终端中输入命令：python manage.py startapp polls
#############################################################



/etc/init.d/nginx configtest 检查配置，不报错
/etc/init.d/nginx restart 重启nginx
sudo tree /etc/nginx
/etc/nginx				  #nginx的配置文件主目录
/etc/nginx/nginx.conf		#nginx的主配置文件，全局配置.

/etc/nginx/conf.d		  #附加配置文件目录
/etc/nginx/conf.d/default.conf  #nginx初始提供的默认子配置文件

/var/cache/nginx							#nginx缓存相关的路径
/var/log/nginx								#nginx的日志记录的路径
service nginx reload 重新加载配置
/var/www/html为网站文件存放的地方, 默认只有Nginx欢迎页面, 可以通过改变Nginx配置文件的方式来修改这个位置.
3. /etc/nginx/sites-available
这个目录存储每一个网站的"server blocks", Nginx通常不会使用这些配置, 除非它们被链接到sites-enabled目录. 一般所有的server block配置都在这个目录中设置, 然后软链接到别的目录.
4. /etc/nginx/sites-enabled
这个目录存储生效的"server blocks"配置. 通常, 这个配置都是链接到sites-available目录中的配置文件.只有在 sites-enabled 目录下的配置文件才能够真正被用户访问
5. /etc/nginx/snippets
这个目录主要可以包含在其它Nginx配置文件中的配置片段, 重复的配置都可以重构为配置片段.
1. /var/log/nginx/access.log
每一个访问请求都会默认记录在这个文件中, 除非你做了其它设置.
2. /var/log/nginx/error.log
任何Nginx的错误信息都会记录到这个文件中.

~/sites/demo.zmrenwu.com/django-blog-tutorial$ sudo ln -s /etc/nginx/sites-available/myblog.com /etc/nginx/sites-enabled/myblog.com

gunicorn启动django
(env) yangxg@localhost:~/sites/demo.zmrenwu.com/django-blog-tutorial$ gunicorn -w 4 -b 0.0.0.0:8000 blogproject.wsgi:application （要进去其作目录下运行该命令，不然启动不成功）

媒体文件：用户上传的文件
静态文件：css,js，image等
开发环境：使用django内置服务器处理静态文件
生产环境：使用apache2/nginx服务器处理静态文件映射


开发环境下，是在各自的app下创建static文件夹，setting.py中 DEBUG = True，是通过使用django内置服务器访问静态文件
在生成环境中，集中存放静态资源有利于使用Lighttpd/Nginx托管静态资源。而生产环境一般是把静态文件放在项目根目录下的static目录（STATIC_ROOT = os.path.join(BASE_DIR, 'static')）下，python manage.py collectstatic收集所有已安装的APP的静态文件到根目录的
STATIC_URL = '/statica/'  #模板渲染时 url静态文件路径的前缀,注意前缀家的是相对路径

shift+F5 强制浏览器清空缓存，很有用哦。浏览器往往会缓存静态文件

sftp://root0@175.168.1.147/home/root0/sites/myblog.com/blogproject/static/static/blog/css/bootstrap.min.css



Nginx配置
	1、/etc/nginx/sites-available/ 目录下新建一个配置文件，，文件名我一般就设置为域名
	2、建立软连接到sites-enabled  ln -s /etc/nginx/sites-available/myblog.com /etc/nginx/sites-enabled/myblog.com							
								
								
								
server {
    charset utf-8;
    listen 8001;
    server_name 175.168.1.147;

    location /static {
        alias /home/root0/sites/myblog.com/blogproject/static;
        #root /home/root0/sites/myblog.com/blogproject/static
    }


    location / {
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/175.168.1.147;
    }
}


svn://192.168.5.12/Develop/Export/SecurityCompetitionScoreDisplay


######启动Nginx服务
[root@typecodes ~]# service nginx start
######停止Nginx服务
[root@typecodes ~]# service nginx stop
######重启Nginx服务
[root@typecodes ~]# service nginx restart
######Nginx服务的状态
[root@typecodes ~]# service nginx status
######在Nginx服务启动的状态下，重新加载nginx.conf这个配置文件
[root@typecodes ~]# service nginx reload #不检查配置文件是否错误
sudo nginx -s reload #要检查配置文件是否错误，建议用这个替换



1.Ubuntu下安装Nginx比较简单
    sudo apt-get update
    sudo apt-get install nginx
 

2.Ubuntu下卸载，稍不注意就会入坑
	sudo service nginx stop  #先停掉nginx
    sudo apt-get remove nginx nginx-common # 卸载删除除了配置文件以外的所有文件。
    sudo apt-get purge nginx nginx-common # 卸载所有东东，包括删除配置文件。
    sudo apt-get autoremove # 在上面命令结束后执行，主要是卸载删除Nginx的不再被使用的依赖包。
    sudo apt-get remove nginx-full nginx-common #卸载删除两个主要的包。

项目总结：
	post_list = Post.objects.all().order_by('-created_time')
	return render(request, 'blog/index.html', context={'post_list': post_list})
	def __str__(self):
			return self.title
	class Meta:
			ordering = ['-created_time']
	title = models.CharField(max_length=70)
	body = models.TextField() #大段文本
	created_time = models.DateTimeField()
	modified_time = models.DateTimeField()
	
    excerpt = models.CharField(max_length=200, blank=True) # 指定 CharField 的 blank=True 参数值后就可以允许空值了。
	category = models.ForeignKey(Category,on_delete=models.CASCADE)
    tags = models.ManyToManyField(Tag, blank=True)
	views = models.PositiveIntegerField(default=0)  #PositiveIntegerField？
	return reverse('blog:detail', kwargs={'pk': self.pk})
	
	def increase_views(self):
        self.views += 1
        self.save(update_fields=['views'])
	from django.shortcuts import render, get_object_or_404
	import markdown
	return render(request, 'blog/index.html', context={'post_list': post_list})
	
	post.body = markdown.markdown(post.body,
                                  extensions=[
                                      'markdown.extensions.extra',
                                      'markdown.extensions.codehilite',
                                      'markdown.extensions.toc',
                                  ])
								  
	comment_list = post.comment_set.all()  #帅选出comment
	post_list = Post.objects.filter(created_time__year=year,
                                    created_time__month=month
                                    ).order_by('-created_time')

	cate = get_object_or_404(Category, pk=pk)
	url = models.URLField(blank=True)
	email = models.EmailField(max_length=255)
	created_time = models.DateTimeField(auto_now_add=True)  #时间自动生成
	url(r'^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$', views.archives, name='archives'),
	
	class PostAdmin(admin.ModelAdmin):
    list_display = ['title', 'created_time', 'modified_time', 'category', 'author']
	admin.site.register(Post)
	admin.site.register(Category)
	admin.site.register(Tag)

	urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'', include('blog.urls')),
    url(r'', include('comments.urls')),
]
	if request.method == 'POST':
	if form.is_valid():
	
	# 将评论和被评论的文章关联起来。
    comment.post = post  ????
	
	{% extends 'base.html' %}
	{% block main %} #main是block名字，可替换成任意名字
	{% endblock main %}
	<form action="{% url 'comments:post_comment' post.pk %}" method="post" class="comment-form">
	{% for post in post_list %}
	{% empty %}
	{% endfor %}
	{% load staticfiles %}
	<script src="{% static 'blog/js/jquery-2.1.3.min.js' %}"></script>
    <script src="{% static 'blog/js/bootstrap.min.js' %}"></script>
	models.Model 自带save方法吗？super(Post, self).save(*args, **kwargs)
	url(r'^$', views.IndexView.as_view(), name='index'),
	return super(CategoryView, self).get_queryset().filter(category=cate)
	from django.views.generic import ListView, DetailView
	from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
	
    {% if is_paginated %}
      {% if page_obj.has_previous %}
      {% endif %}

      {% if page_obj.has_next %}
      {% endif %}
    {% endif %}

	{% if is_paginated %}
	<div class="pagination-simple">
	  <!-- 如果当前页还有上一页，显示一个上一页的按钮 -->
	  {% if page_obj.has_previous %}
		<a href="?page={{ page_obj.previous_page_number }}">上一页</a>
	  {% endif %}
	  <!-- 显示当前页面信息 -->
	  <span class="current">第 {{ page_obj.number }} 页 / 共 {{ paginator.num_pages }} 页</span>
	  <!-- 如果当前页还有下一页，显示一个下一页的按钮 -->
	  {% if page_obj.has_next %}
		<a href="?page={{ page_obj.next_page_number }}">下一页</a>
	  {% endif %}
	</div>
	{% endif %}
	from django.db.models.aggregates import Count
	tag = get_object_or_404(Tag, pk=self.kwargs.get('pk'))

	from blog.feeds import AllPostsRssFeed
	urlpatterns = [
    url(r'^all/rss/$', AllPostsRssFeed(), name='rss'),
]	
	 {{ post.toc|safe }} safe 标签防止 Django 对其转义
	 django.utils.text 中的 slugify 方法，该方法可以很好地处理中文。
	 from django.utils.text import slugify
	from markdown.extensions.toc import TocExtension
	 md = markdown.Markdown(extensions=[
            'markdown.extensions.extra',
            'markdown.extensions.codehilite',
            # 'markdown.extensions.toc', #toc 目录
            TocExtension(slugify=slugify),
        ])
	from django.utils.text import slugify
	from django.db.models import Q
	
	<form role="search" method="get" id="searchform" action="{% url 'blog:search' %}">   #form get提交
        <input type="search" name="q" placeholder="搜索" required>
        <button type="submit"><span class="ion-ios-search-strong"></span></button>
    </form>

	def search(request):
		q = request.GET.get('q')
		error_msg = ''

		if not q:
			error_msg = "请输入关键词"
			return render(request, 'blog/index.html', {'error_msg': error_msg})

		post_list = Post.objects.filter(Q(title__icontains=q) | Q(body__icontains=q))
		return render(request, 'blog/index.html', {'error_msg': error_msg,
                                               'post_list': post_list})
											
		django haystack 的规定。要相对某个 app 下的数据进行全文检索，就要在该 app 下创建一个 search_indexes.py 文件，


	try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")


xamdin替换掉原生的admin步骤：
	0、安装xadmin依赖包，pip uninstall xadmin 卸掉库里的包，因为项目中用的是xadmin源码；
	1、将xadmin源码包加入到项目中；
	2、setting.py中的app中注册；
	3、setting.py中加入 AUTH_USER_MODEL = 'users.UserProfile'；
	4、项目的urls.py中改成 urlpatterns = [path('xadmin/', xadmin.site.urls),]，替换以前的admin路由；

四个app下面都新建文件adminx.py，然后分别注册到后台
xadmin添加富文本插件
xadmin/plugins文件夹下新建文件ueditor.py
把插件添加到__init__.py里面
	# xadmin/plugins/__init__.py

	PLUGINS = (
		'ueditor',
	)
MxShop/urls.py配置xadmin和ueditor的路由
注册app到xadmin后台
	a.app下面都新建文件adminx.py
	b.# users/apps.py修改app名字为中文
	c.users/__init__.py中 default_app_config = 'users.apps.UsersConfig'
from django.forms.models import model_to_dict 与 from django.core import serializers

pip install coreapi                         drf的文档支持
pip install django-guardian           drf对象级别的权限支持
在app目录下新建一个 adminx.py 文件 xadmin会自动查找到adminx.py这个文件
模块若定义了__all__属性，则只有__all__内指定的属性、方法、类可被导入；若没定义，则导入模块内的所有公有属性，方法和类。

序列化问题：
	方式一、手动加。如：json_dict = {}，json_dict['name'] = good.name；
	
	方式二、model_to_dict，可以将model整个转化为dict，ImageFieldFile 和add_time字段不能序列化，遇到这种字段会报错；
		from django.forms.models import model_to_dict
        for good in goods:
            json_dict = model_to_dict(good)
            json_list.append(json_dict)

        from django.http import HttpResponse
        import json
        #返回json，一定要指定类型content_type='application/json'
        return HttpResponse(json.dumps(json_list),content_type='application/json')
		
	方式三、django的serializers，字段序列化定死的，要想重组的话非常麻烦；
		json_data = serializers.serialize('json',goods)
        json_data = json.loads(json_data)
        #In order to allow non-dict objects to be serialized set the safe parameter to False.
        return JsonResponse(json_data,safe=False)
		
		a.结合drf重组（需要自己手动添加字段序列化）：
			goods/serializers.py：
				class GoodsSerializer(serializers.Serializer):
				name = serializers.CharField(required=True,max_length=100)
				click_num = serializers.IntegerField(default=0)
				goods_front_image = serializers.ImageField()   #会自动得到从项目更目录开始的全路径
			goods/views.py：
				from rest_framework.views import APIView
				from goods.serializers import GoodsSerializer

				class GoodsListView(APIView):
					'''
					商品列表
					'''
					def get(self,request,format=None):
						goods = Goods.objects.all()
						goods_serialzer = GoodsSerializer(goods,many=True)
						return Response(goods_serialzer.data)
						
		b.Modelserializer，会更加的方便，直接用__all__就可以全部序列化:
			goods/serializers.py:
				from rest_framework import serializers
				#ModelSerializer实现商品列表页
				class GoodsSerializer(serializers.ModelSerializer):
					class Meta:
						model = Goods
						fields = '__all__'   #model中的类全部序列化


npm与cnpm：npm是国外的，他的的国内镜像是cnpm，下载包更快。
vue-cli
	1、安装node.js，安装node.js会附带安装npm工具
		查看版本：
			C:\Users\Administrator\Desktop\demo\mxshop\online-store>node -v
			v12.13.1

			C:\Users\Administrator\Desktop\demo\mxshop\online-store>npm -v
			6.12.1
	2、cd 到项目，安装项目依赖：npm install，安装成功后你会发现项目里多了个node_modules文件夹；
	3、运行项目：C:\Users\Administrator\Desktop\demo\mxshop\firstvue>npm run dev (package.json中scripts是否定义dev)
	4、打包:C:\Users\Administrator\Desktop\demo\mxshop\firstvue>npm run build，会多出dist文件夹，用于生成环境；


ViewSet 类只是一种基于类的 View，它不提供任何处理方法，如 .get() 或 .post()，而是提供诸如  .list() 和 .create() 之类的操作。
ViewSet 只在用 .as_view() 方法绑定到最终化视图时做一些相应操作
user_list = UserViewSet.as_view({'get': 'list'})
user_detail = UserViewSet.as_view({'get': 'retrieve'})


GenericViewSet(ViewSetMixin, generics.GenericAPIView)       ---DRF
    GenericAPIView(views.APIView)                           ---DRF
        APIView(View)                                       ---DRF 重写as_view()、permission_denied()、get_authenticate_header()
            View                                            ---Django as_view()、dispatch()

cbv:（from django.views.generic import Vie）class-based-view（以下简称cbv）
	Django的url是将一个请求分配给可调用的函数的，而不是一个class。针对这个问题，
	class-based view提供了一个as_view()静态方法（也就是类方法），调用这个方法，
	会创建一个类的实例，然后通过实例调用dispatch()方法，dispatch()方法会根据
	request的method的不同调用相应的方法来处理request（如get() , post()等）
	dispatch:派遣
	
一个View Class可以继承多个Mixin，但是只能继承一个View（包括View的子类），推荐把View写在最右边，多个Mixin写在左边。

as_view： as_view执行完，返回是view（函数名）
  调用
  view： view函数的返回值，return self.dispatch(request, *args, **kwargs)
  调用
 dispatch：函数体有get、post等方法，return handler(request, *args, **kwargs)，判断请求方式是否在这个请求方式列表中，self.http_method_names：['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']
  调用
 handler ：handler就是反射得到的实例方法，如get
 
 
 1.APIView:
可以使用drf的request对象。
可以用drf中的reponse对象。
完善的异常处理功能。
验证功能：身份验证，权限验证，访问次数验证

2.GenericAPIView视图类：（继承自APIView
GenericAPIView.generic和ListModelAPIView等等的封装了数据库操作方法的类 一起使用，需要定义get,post,put…的方法
属性queryset================ >指定查询集
属性serializer_class ======== >指定序列化器类型
方法get_queryset() ========== >获取查询集，默认是通过属性获取，可重写
方法get_serializer_class() ============ >获取序列化器类型，默认是通过属性获取，可重写
方法get_serializer() ======== >获取序列化器对象，调用上面的方法
方法get_object()============>根据主键在集集上获取对象，可重写

注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。
比如在序列化其中通过 self.context.get(“request”).user 来获取当前登录的用户对象
3.generic.+合成的数据库操作类（需要指定查询集和序列化类，省去了写方法）
generic.ListCreateAPIView
generic.RetrieveAPIView
generic.UpdateAPIView
generic.DestroyAPIView
generic.RetrieveUpdateAPIView
generic.RetrieveDestroyAPIView
generic.RetrieveUpdateDestroyAPIView

4.viewsets.ModelViewSet() 视图集 （需要指定查询集和序列化类，省去了写方法，需要根据DefaultRouter创建路由）
作用：将所有关于数据操作的方法，定义在同一个类中
实现思路：重写as_view()、dispatch()方法，接收字典作为参数，将请求方式小写作为键，在字典中查找方法名称，再执行
1.常用的类：
ModelViewSet，包含了增加、修改、删除、查询多个、查询一个的功能
ReadOnlyModelViewSet，包含了查询多个、查询一个的功能
2.以上两个类，继承自GenericAPIView，在使用时，可以通过属性或方法指定查询集、序列化器
3.扩展
装饰器action可以扩展方法
属性action可以获取当前执行方法的名称
注册路由规则：使用DefaultRouter类配合
Router中定义了mapping={
                'get': 'list',
                'post': 'create'
            }
			mapping={
                'get': 'retrieve',
                'put': 'update',
                'patch': 'partial_update',
                'delete': 'destroy'
            }，mapping传入到as_view中，用DefaultRouter默认url，不写as_view中的匹配字典了


class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet)
class SmsCodeViewset(CreateModelMixin,viewsets.GenericViewSet):
class UserViewset(CreateModelMixin,viewsets.GenericViewSet):
class CategoryViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): 
在试图类里指定序列化类：
	serializer_class = UserRegSerializer
	
serializers.Serializer):   #注意此处不是继承ModelSerializer，与serializers.ModelSerializer不同，不存在model与serial绑定。通过serializer_class，sercial与view绑定
    class Meta:
        model = User  # model与serial绑定

使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或者保存成模型类对象。
在获取反序列化数据前，必须调用is_valid()方法进行验证，验证成功返回True，否则返回False。
验证失败，可以通过序列化器对象的errors属性获取错误信息，返回内容为字典，包含字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的NON_FIELD_ERRORS_KEY来控制错误字典中的键名。
验证成功，可以通过序列化器对象的validated_data属性获取数据。
serializer.save()如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用

类视图生成的api，参数传递的字段 是根据序列化类中的字段

-validate(self,attrs)
	-attrs所有校验通过的数据，是个字典
前端使用的数据都是序列化后的数据；后端使用的都是反序列化的数据

payload = jwt_payload_handler(user)  #dict类型
re_dict["token"] = jwt_encode_handler(payload)  #str类型，将dict各个字段加密后，拼接成一长串字符串，放到token里，返回给前端

权限检查总是在视图的最开始处运行，在任何其他代码被允许进行之前。权限检查通常会使用 request.user 和 request.auth 属性中的认证信息来确定是否允许传入请求
成功身份验证的第一个类的返回值赋值给request.user request.auth

如果前台携带了认证信息并认证通过，定位为登录用户，将登录的用户user对象保存在 requset.user 中，先认证，再权限

试图类函数中看api传参，看request.data ，dict类型

序列化类中验证的字段，必须包含在fields里，传递给post试图类中，如create，request.data
def create(self, request, *args, **kwargs):
    print(request.data)
    serializer = self.get_serializer(data=request.data)

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)  #post中序列化的是request.data
        serializer.is_valid(raise_exception=True)
        user = self.perform_create(serializer)
        re_dict = serializer.data
        payload = jwt_payload_handler(user)
        re_dict["token"] = jwt_encode_handler(payload)
        re_dict["name"] = user.name if user.name else user.username
        headers = self.get_success_headers(serializer.data)
        return Response(re_dict, status=status.HTTP_201_CREATED, headers=headers)
		
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())    #序列化的是queryset集合
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
		
^ ^userfavs/(?P<goods_id>[^/.]+)/$ [name='userfavs-detail']
	# http://127.0.0.1:8000/userfavs/?goods_id=1/ GET
	# http://127.0.0.1:8000/userfavs/?goods_id=1/15ede GET 可以访问 [^/.]+ 表示这部分可选，任意多个字符

drf
	[View(django)-->ApiView(drf)-->GengricApiView]
	GengricApiView -->GenericViewSet
	(GenericAPIView、ViewSetMixin)-->GenericViewSet
	
	在Mixin中一共有5个分别是
		CreateModelMixin(post，增)，
		ListModelMixin(get，查),
		RetrieveModelMixin(get，附带参数)
		UpdateModelMixin(put/patch,改)
		DestroyModelMixin(delete,删)
类方式定义视图：
	path('getmydata/',mydata.as_view()),
	
	from rest_framework.views import APIView
	from rest_framework.response import Response
	from django.views.generic import View  #django 原生view
	from django.http import HttpResponse #django 原生HttpResponse
	class mydata(APIView):  #
		def get(self, request, format11=None):  #此处get请求中，request没有传递内容，可以不写request，但不建议这么做
			return HttpResponse("HELLO")  #没有网页渲染效果，尽量view和response配套使用
			return Response("HELLO")  #有网页渲染效果，尽量view和response配套使用
			return "hello000000000"  #这种会报错，因为试图类中，此处搭配as_view()函数，不接受str类型
			return render(request,"blog/blog_list.html", context=context)  #from django.shortcuts import render
函数方式定义视图：		
	path('getmydata/',gettt),
	
	from django.http import HttpResponse	
	def gettt(request):  # 此处get请求中，必须要有request参数
		return HttpResponse("HELLO")  #
		
	
第一类：原始继承APIView
        # http://127.0.0.1:8000/api/v1/auth/
        url(r'^auth/$', views.AuthView.as_view()),

        # http://127.0.0.1:8000/api/v1/auth.json # 想要让页面显示json格式
        url(r'^auth\.(?P<format>[a-z0-9]+)$', views.AuthView.as_view()),

        # http://127.0.0.1:8000/api/v1/auth/1/
        url(r'^auth/(?P<pk>\d+)/$', views.AuthView.as_view()),

        # http://127.0.0.1:8000/api/v1/auth/1.json
        url(r'^auth/(?P<pk>\d+)\.(?P<format>[a-z0-9]+)$', views.AuthView.as_view()),

ser = serializer.save()
print("type",type(ser))
print(ser.__dict__)
ser = serializer.save() 是对应app中的models实例，
#<class 'user_operation.models.UserAddress'>  是user_operation app中的UserAddress models类。是这个类的实例，有具体的字段（数据）
用docs api里测试接口，添加models在数据库表里的id，就算添加了models实例了 ？

总结::::::::::::::::::::::
	ser = serializer.save() #<class 'user_operation.models.UserAddress'>  是user_operation app中的UserAddress models类。是这个类的实例，有具体的字段（数据）

	django.db.models.query.QuerySet 查询数据库返回的集合
	django.db.models.Model
	existed = ShoppingCart.objects.filter(user=user, goods=goods) #QuerySet类型
	existed[0] #迭代转换成trade.models.ShoppingCart类型，这种类型才可以.字段
	existed.nums += nums   #.字段
	existed.save()     #trade.models.ShoppingCart类型才有save方法

	serializers.ModelSerializer中有create、update方法，serializers.Serializer没有这两个方法

	user = self.context["request"].user  ????

	def get_serializer_class(self):
		print(self) #trade.views.ShoppingCartViewset类型
		print(self.action) #trade.views.ShoppingCartViewset类型有action属性
		
	shop_cart = serializer.save()   # shop_cart类型:<class 'trade.models.ShoppingCart'>
	goods = shop_cart.goods   # 经过serializer.save() 后，才能.字段。此处goods字段是models.ShoppingCart的外键，通过外键"点"出来实例【<class 'goods.models.Goods'>】来。                                       #instance的goods字段，

	视图类：class ShoppingCartViewset(viewsets.ModelViewSet): #因为继承ModelViewSet，ModelViewSet又继承了ListModelMixin，所以必须在视图类里指定queryset对象
				def get_queryset(self):
					return ShoppingCart.objects.filter(user=self.request.user)
	序列化类：class ShopCartSerializer(serializers.Serializer) 
	write_only=True,单方向校验，没有默认是双方向，过不了校验
	序列化，先校验后保存:   serializer.is_valid(raise_exception=True) ,serializer.save()
	
	视图类中 def perform_create(self, serializer): #self:<trade.views.ShoppingCartViewset  serializer:<class 'trade.serializers.ShopCartSerializer'> 
	serializer.data
	goods.__dict__
	view中:self.request.user；serizlizer中:self.context["request"].user
	goods = serializers.PrimaryKeyRelatedField(required=True, queryset=Goods.objects.all()) ???????
	
	class ShopCartSerializer(serializers.Serializer):
	    test = serializers.CharField(required=True, label="测试，备注",write_only=True)# write_only 只能前端到后台，没有将test字段绑定在models里，所以后面的save，不用把test字段删除
																						
		def create(self, validated_data):
			user = self.context["request"].user
			nums = validated_data["nums"]
			goods = validated_data["goods"]

			existed = ShoppingCart.objects.filter(user=user, goods=goods)  #<QuerySet []>
			if existed:
				existed = existed[0] #<class 'trade.models.ShoppingCart'>
				existed.nums += nums
				existed.save()  #不会把之前创建的test字段删除，因为test ShoppingCart
			else:
				existed = ShoppingCart.objects.create(**validated_data)
			return existed

		def update(self, instance, validated_data):
			instance.nums = validated_data["nums"]
			instance.save()
			return instance
		
	不管继承serializers.ModelSerializer 还是继承serializers.Serializer，ModelSerializer默认会绑定models，
	添加非models字段，要加write_only,表明是反序列化，要存入数据库的。在调用serial的save前，
	只要绑定到models里了的字段都要删除非models字段，否则不能save
	
	当用serializers.ModelSerializer序列化models时，默认的字段用于读写(get、post)，当models里字段没有默认值，同时又是post的字段，则该字段是必须字段，必须填写字段值，才能post

	alipay_url = serializers.SerializerMethodField(read_only=True)  #非models字段，只读，不会保存至数据库，所以不用删除该字段

	vue项目中api.js里面local_host改为服务器ip

	0 是 0.0.0.0 的简写，Django将运行在0.0.0.0:8000上，整个局域网内都将可以访问站点，而不只是是本机。


python manage.py shell DJANGO_SETTINGS_MODULE环境变量导入，它将自动按照mysite/settings.py中的设置，配置好你的python shell环境，这样，你就可以导入和调用任何你项目内的模块了。
或者
	>>> import django
	>>> django.setup()
在实际环境中，为了站点的安全性，我们一般不能将管理后台的url随便暴露给他人，不能用/admin/这么简单的路径

path('<int:question_id>/results/', views.results, name='results'),  question_id必须与试图函数里的参数名一致，否则会报错
项目的 TEMPLATES配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 "templates" 子目录。

为什么要在template文件夹里创建个子文件夹：
	项目的 TEMPLATES配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 "templates" 子目录。这就是为什么尽管我们没有像在第二部分中那样修改 DIRS 设置，Django 也能正确找到 polls 的模板位置的原因。
	在templates目录中，再创建一个新的子目录名叫polls，进入该子目录，创建一个新的html文件index.html。换句话说，你的模板文件应该是polls/templates/polls/index.html。因为 Django 会寻找到对应的app_directories ，所以你只需要使用polls/index.html就可以引用到这一模板了。
	你也许会想，为什么不把模板文件直接放在polls/templates目录下，而是费劲的再建个子目录polls呢?设想这么个情况，有另外一个app，它也有一个名叫index.html的文件，当Django在搜索模板时，有可能就找到它，然后退出搜索，这就命中了错误的目标，不是我们想要的结果。解决这个问题的最好办法就是在templates目录下再建立一个与app同名的子目录，
	将自己所属的模板都放到里面，从而达到独立命名空间的作用，不会再出现引用错误。

模板中硬编码：
	<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
模板中软编码：
	<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
	Django会在polls.urls文件中查找name='detail'的url，具体的就是下面这行：
	path('<int:question_id>/', views.detail, name='detail'),
URLconf的命名空间。
	各自的app的urls.py里添加一个app_name的变量来指定该应用的命名空间
	如：app_name = 'polls'  #urlconf 命名空间，结合<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>使用

由于我们发送了一个POST请求，就必须考虑一个跨站请求伪造的安全问题，简称CSRF（具体含义请百度）。Django为你提供了一个简单的方法来避免这个困扰，那就是在form表单内添加一条{% csrf_token %}标签，


字段命名约束：
	Django不允许下面两种字段名：
	与Python关键字冲突。这会导致语法错误。例如：
	class Example(models.Model): pass = models.IntegerField() # 'pass'是Python保留字！
	字段名中不能有两个以上下划线在一起，因为两个下划线是Django的查询语法。例如：
	class Example(models.Model): foo__bar = models.IntegerField() # 'foo__bar' 有两个下划线在一起!


这里有如何上传文件和图片的方法：
	1.FileField：
	class FileField(upload_to=None, max_length=100, **options)[source]
	上传文件字段（不能设置为主键）。默认情况下，该字段在HTML中表现为一个ClearableFileInput标签。
	在数据库内，我们实际保存的是一个字符串类型，默认最大长度100，
	可以通过max_length参数自定义。真实的文件是保存在服务器的文件系统内的。
	2. ImageField
	class ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)[source]
	用于保存图像文件的字段。其基本用法和特性与FileField一样，只不过多了两个属性height和width。默认情况下，
	该字段在HTML中表现为一个ClearableFileInput标签。在数据库内，我们实际保存的是一个字符串类型，
	默认最大长度100，可以通过max_length参数自定义。真实的图片是保存在服务器的文件系统内的。
	在settings文件中，配置MEDIA_ROOT，作为你上传文件在服务器中的基本路径（为了性能考虑，这些文件不会被储存在数据库中）。
	再配置个MEDIA_URL，作为公用URL，指向上传文件的基本路径。请确保Web服务器的用户账号对该目录具有写的权限。
	添加FileField或者ImageField字段到你的模型中，定义好upload_to参数，文件最终会放在MEDIA_ROOT目录的“upload_to”子目录中。
	所有真正被保存在数据库中的，只是指向你上传文件路径的字符串而已。可以通过url属性，在Django的模板中方便的访问这些文件。
	例如，假设你有一个ImageField字段，名叫mug_shot，那么在Django模板的HTML文件中，可以使用{{ object.mug_shot.url }}来获取该文件。
	其中的object用你具体的对象名称代替。可以通过name和size属性，获取文件的名称和大小信息。
	--务必对所有的上传文件进行安全检查
	
如果要创建一个递归的外键，也就是自己关联自己的的外键，使用下面的方法：
	models.ForeignKey('self', on_delete=models.CASCADE)

related_name
	用于关联对象反向引用模型的名称。以前面车和工厂的例子解释，就是从工厂反向关联到车的关系名称。
	通常情况下，这个参数我们可以不设置，Django会默认以模型的小写加上_set作为反向关联名，比如对于工厂就是car_set，如果你觉得car_set还不够直观，可以如下定义：
	class Car(models.Model):
		manufacturer = models.ForeignKey(
			'production.Manufacturer',      
			on_delete=models.CASCADE,
			related_name='car_producted_by_this_manufacturer',  # 看这里！！
		)
	也许我定义了一个蹩脚的词，但表达的意思很清楚。以后从工厂对象反向关联到它所生产的汽车，就可以使用maufacturer.car_producted_by_this_manufacturer了。
	如果你不想为外键设置一个反向关联名称，可以将这个参数设置为“+”或者以“+”结尾，如下所示：
	user = models.ForeignKey(
		User,
		on_delete=models.CASCADE,
		related_name='+',
	)

	class Base(models.Model):
		m2m = models.ManyToManyField(
		OtherModel,
		related_name="%(app_label)s_%(class)s_related",
		related_query_name="%(app_label)s_%(class)ss",
		)

一对一（OneToOneField）
	一对一关系类型的定义如下：
	class OneToOneField(to, on_delete, parent_link=False, **options)[source]
	从概念上讲，一对一关系非常类似具有unique=True属性的外键关系，但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。
	比如，Django自带auth模块的User用户表，如果你想在自己的项目里创建用户模型，
	又想方便的使用Django的认证功能，那么一个比较好的方案就是在你的用户模型里，使用一对一关系，添加一个与auth模块User模型的关联字段。
	该关系的第一位置参数为关联的模型，其用法和前面的多对一外键一样。
	**如果你没有给一对一关系设置related_name参数，Django将使用当前模型的小写名作为默认值。
	from django.conf import settings
	from django.db import models

	# 两个字段都使用一对一关联到了Django内置的auth模块中的User模型
	class MySpecialUser(models.Model):
		user = models.OneToOneField(
			settings.AUTH_USER_MODEL,
			on_delete=models.CASCADE,
		)
		supervisor = models.OneToOneField(
			settings.AUTH_USER_MODEL,
			on_delete=models.CASCADE,
			related_name='supervisor_of',
		)
		
choices
	用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，
	第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如：

		YEAR_IN_SCHOOL_CHOICES = (
			('FR', 'Freshman'),
			('SO', 'Sophomore'),
			('JR', 'Junior'),
			('SR', 'Senior'),
			('GR', 'Graduate'),
		)
		
自定义中间表
	使用自定义中间表的多对多不能使用add(), create(),remove(),和set()方法来创建、删除关系，
	唯一的办法只能是通过创建中间模型的实例来创建这种类型的多对多关联
	
def hash_code(s, salt='mysite'):
    h = hashlib.sha256()
    s += salt
    h.update(s.encode())
    return h.hexdigest()

***************安装代码审查模块************************************************
pip install pylint
pip install yapf
pip install pylint_django
***************************************************************
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple  django==2.2 从国内镜像安装